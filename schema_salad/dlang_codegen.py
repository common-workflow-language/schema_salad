"""D code generator for a given schema salad definition."""

from typing import Any, IO, Dict, List, Optional, Tuple, Union, cast
from .codegen_base import CodeGenBase, TypeDef
from .exceptions import SchemaException
from .schema import shortname

from . import _logger
from . import schema
from .cpp_codegen import pred, isArray, isRecordSchema, isEnumSchema

import textwrap
import datetime


class DlangCodeGen(CodeGenBase):
    def __init__(
        self,
        base: str,
        target: IO[str],
        examples: Optional[str],
        package: str,
        copyright: Optional[str],
        parser_info: Optional[str],
    ) -> None:
        super().__init__()
        self.base_uri = base
        self.examples = examples
        self.target = target
        self.package = package
        self.copyright = copyright
        self.parser_info = parser_info
        self.docRootTypes = []


    def prologue(self) -> None:
        """Trigger to generate the prolouge code."""
        self.target.write(
            f"""/**
 * Generated by schema-salad code generator
 *
 * Date: {datetime.date.today().isoformat()}
"""
        )
        if self.copyright:
            self.target.write(f" * Copyright: {self.copyright}\n")
        self.target.write(f""" */
module {self.package};

import salad.meta.dumper : genDumper;
import salad.meta.impl : genCtor, genIdentifier, genOpEq;
import salad.meta.parser : import_ = importFromURI;
import salad.meta.uda : documentRoot, id, idMap, link, typeDSL;
import salad.primitives : SchemaBase;
import salad.type : None, Either;

""")
        if self.parser_info:
            self.target.write(f'''/// parser information
enum parserInfo = "{self.parser_info}";
''')

    def epilogue(self, root_loader: TypeDef) -> None:
        docRootTypeStr = ", ".join(self.docRootTypes)
        docRootType = f"Either!({docRootTypeStr})"
        self.target.write(f"""
///
alias DocumentRootType = {docRootType};

///
alias importFromURI = import_!DocumentRootType;
""")

    @staticmethod
    def safe_name(name: str) -> str:
        avn = schema.avro_field_name(name)
        if avn in ("class", "abstract", "default", "package"):
            # reserved words
            avn = avn + "_"
        if avn and avn.startswith("anon."):
            avn = avn[5:]
        return avn


    def toDocComment(self, doc: Union[None, str, List[str]]):
        if doc is None:
            return "///\n"
        elif isinstance(doc, str):
            lines = doc.split("\n")
        else:
            lines = sum((d.split("\n") for d in doc), [])
        
        docLines = "\n".join((f" * {l}" for l in lines if len(l)))

        return f"""/**
{docLines}
 */
"""


    def parseRecordFieldType(self, type: Any, jsonldPred: Union[None, str, dict]) -> Tuple[str, str]:
        annotations = []
        if isinstance(jsonldPred, str):
            if jsonldPred == "@id":
                annotations.append("@id")
        elif isinstance(jsonldPred, dict):
            if jsonldPred.get("typeDSL", False):
                annotations.append("@typeDSL")
            if "mapSubject" in jsonldPred:
                subject = jsonldPred["mapSubject"]
                if "mapPredicate" in jsonldPred:
                    pred = jsonldPred["mapPredicate"]
                    annotations.append(f'@idMap("{subject}", "{pred}")')
                else:
                    annotations.append(f'@idMap("{subject}")')
            if jsonldPred.get("_type", "") == "@id":
                annotations.append("@link")
        if len(annotations):
            annotateStr = " ".join(annotations)+" "
        else:
            annotateStr = ""

        if isinstance(type, str):
            stype = shortname(type)
            if stype == "boolean":
                typeStr = "bool"
            elif stype == "null":
                typeStr = "None"
            else:
                typeStr = stype
        elif isinstance(type, list):
            tStr = []
            for t in type:
                elemType = self.parseRecordFieldType(t, None)[1]
                tStr.append(elemType)
            unionTypes = ", ".join(tStr)
            typeStr = f"Either!({unionTypes})"
        elif shortname(type["type"]) == "array":
            itemType = self.parseRecordFieldType(type["items"], None)[1]
            typeStr = f"{itemType}[]"
        elif shortname(type["type"]) == "record":
            return annotateStr, shortname(type.get("name", "record"))
        elif shortname(type["type"]) == "enum":
            return annotateStr, "'not yet implemented'"
        return annotateStr, typeStr


    def parseRecordField(self, field: Dict[str, Any], parentName: Optional[str] = None) -> str:
        fname = shortname(field["name"])+"_"
        jsonldPred = field.get("jsonldPredicate", None)
        docComment = self.toDocComment(field.get("doc", None))
        type = field["type"]
        if ((isinstance(type, dict) and shortname(type.get("type", "")) == "enum") or (isinstance(type, str) and shortname(type) == "string")) and isinstance(jsonldPred, dict) and (shortname(jsonldPred.get("_id", "")) == "type" or shortname(jsonldPred.get("_id", "")) == "@type") and jsonldPred.get("_type", "") == "@vocab":
            # special case
            if isinstance(type, dict):
                # assert len(type["symbols"]) == 1
                value = shortname(type["symbols"][0])
            else:
                value = parentName
            return f'{docComment}static immutable {fname} = "{value}";'
        else:
            annotateStr, typeStr = self.parseRecordFieldType(type, jsonldPred)

        return f"{docComment}{annotateStr}{typeStr} {fname};"


    def parseRecordSchema(self, stype: Dict[str, Any]) -> None:
        name = cast(str, stype["name"])
        classname = self.safe_name(name)

        fieldDecls = []
        if "fields" in stype:
            for field in stype["fields"]:
                fieldDecls.append(self.parseRecordField(field, classname))
        declStr = "\n".join((textwrap.indent(f"{d}", " "*4) for d in fieldDecls))

        if stype.get("documentRoot", False):
            docRootAnnotation = "@documentRoot "
            self.docRootTypes.append(classname)
        else:
            docRootAnnotation = ""

        docComment = self.toDocComment(stype.get("doc", None))

        return f"""
{docComment}{docRootAnnotation}class {classname} : SchemaBase
{{
{declStr}

    mixin genCtor;
    mixin genIdentifier;
    mixin genDumper;
}}"""


    def parseEnum(self, stype: Dict[str, Any]) -> str:
        name = cast(str, stype["name"])
        if shortname(name) == "Any":
            return "\n///\npublic import salad.primitives : Any;"
        elif shortname(name) == "Expression":
            return "\n///\npublic import salad.primitives : Expression;"

        classname = self.safe_name(name)
        syms = [f'        s{i} = "{shortname(sym)}"' for i, sym in enumerate(stype["symbols"])]
        symsDef = ",\n".join(syms)

        if stype.get("documentRoot", False):
            docRootAnnotation = "@documentRoot "
            self.docRootTypes.append(classname)
        else:
            docRootAnnotation = ""

        if "doc" in stype:
            docComment = self.toDocComment(stype["doc"])
        else:
            docComment = ""

        return f"""
{docComment}{docRootAnnotation}class {classname} : SchemaBase
{{
    enum Symbol
    {{
{symsDef}
    }}

    Symbol value;

    mixin genCtor;
    mixin genOpEq;
    mixin genDumper;
}}"""


    def parse(self, items: List[Dict[str, Any]]) -> None:
        dlangDefs = []

        self.prologue()

        for stype in items:
            assert "type" in stype

            if "type" in stype and stype["type"] == "documentation":
                continue

            if not (pred(stype) or isArray(stype)):
                raise SchemaException("not a valid SaladRecordField")

            # parsing a record
            if isRecordSchema(stype):
                if stype.get("abstract", False):
                    continue
                dlangDefs.append(self.parseRecordSchema(stype))
            elif isEnumSchema(stype):
                dlangDefs.append(self.parseEnum(stype))
            else:
                _logger.error(f"not parsed{stype}")

        self.target.write("\n".join(dlangDefs))
        self.target.write("\n")

        self.epilogue(None)

        self.target.close()
