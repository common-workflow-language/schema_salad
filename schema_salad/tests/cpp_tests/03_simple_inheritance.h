#pragma once

// Generated by schema-salad code generator

#include <cassert>
#include <cstddef>
#include <cstdint>
#include <map>
#include <string>
#include <string_view>
#include <variant>
#include <vector>
#include <yaml-cpp/yaml.h>
#include <any>

inline auto mergeYaml(YAML::Node n1, YAML::Node n2) {
    for (auto const& e : n1) {
        n2[e.first.as<std::string>()] = e.second;
    }
    return n2;
}

// declaring toYaml
inline auto toYaml(bool v) {
    return YAML::Node{v};
}
inline auto toYaml(float v) {
    return YAML::Node{v};
}
inline auto toYaml(double v) {
    return YAML::Node{v};
}
inline auto toYaml(int32_t v) {
    return YAML::Node{v};
}
inline auto toYaml(int64_t v) {
    return YAML::Node{v};
}
inline auto toYaml(std::any const&) {
    return YAML::Node{};
}
inline auto toYaml(std::monostate const&) {
    return YAML::Node(YAML::NodeType::Undefined);
}

inline auto toYaml(std::string const& v) {
    return YAML::Node{v};
}

inline void addYamlField(YAML::Node& node, std::string const& key, YAML::Node value) {
    if (value.IsDefined()) {
        node[key] = value;
    }
}

inline auto convertListToMap(YAML::Node list, std::string const& key_name) {
    if (list.size() == 0) return list;
    auto map = YAML::Node{};
    for (YAML::Node n : list) {
        auto key = n[key_name].as<std::string>();
        n.remove(key_name);
        map[key] = n;
    }
    return map;
}

// fwd declaring toYaml
template <typename T>
auto toYaml(std::vector<T> const& v) -> YAML::Node;
template <typename T>
auto toYaml(T const& t) -> YAML::Node;
template <typename ...Args>
auto toYaml(std::variant<Args...> const& t) -> YAML::Node;

template <typename T>
class heap_object {
    std::unique_ptr<T> data = std::make_unique<T>();
public:
    heap_object() = default;
    heap_object(heap_object const& oth) {
        *data = *oth;
    }
    heap_object(heap_object&& oth) {
        *data = *oth;
    }

    template <typename T2>
    heap_object(T2 const& oth) {
        *data = oth;
    }
    template <typename T2>
    heap_object(T2&& oth) {
        *data = oth;
    }

    auto operator=(heap_object const& oth) -> heap_object& {
        *data = *oth;
        return *this;
    }
    auto operator=(heap_object&& oth) -> heap_object& {
        *data = std::move(*oth);
        return *this;
    }

    template <typename T2>
    auto operator=(T2 const& oth) -> heap_object& {
        *data = oth;
        return *this;
    }
    template <typename T2>
    auto operator=(T2&& oth) -> heap_object& {
        *data = std::move(oth);
        return *this;
    }

    auto operator->() -> T* {
        return data.get();
    }
    auto operator->() const -> T const* {
        return data.get();
    }
    auto operator*() -> T& {
        return *data;
    }
    auto operator*() const -> T const& {
        return *data;
    }

};

namespace file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml { struct MyRecordOne; }
namespace file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml { struct MyRecordTwo; }
namespace file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml {
struct MyRecordOne {
    heap_object<std::string> name;
    virtual auto toYaml() const -> YAML::Node;
};
}

namespace file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml {
struct MyRecordTwo
    : file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml::MyRecordOne {
    heap_object<int32_t> value;
    auto toYaml() const -> YAML::Node override;
};
}

inline auto file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml::MyRecordOne::toYaml() const -> YAML::Node {
    using ::toYaml;
    auto n = YAML::Node{};
    addYamlField(n, "name", toYaml(*name));
    return n;
}
inline auto file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml::MyRecordTwo::toYaml() const -> YAML::Node {
    using ::toYaml;
    auto n = YAML::Node{};
    n = mergeYaml(n, file____home_gene_Coding_schema_salad_schema_salad_tests_cpp_tests_03_simple_inheritance_yml::MyRecordOne::toYaml());
    addYamlField(n, "value", toYaml(*value));
    return n;
}

template <typename T>
auto toYaml(std::vector<T> const& v) -> YAML::Node {
    auto n = YAML::Node(YAML::NodeType::Sequence);
    for (auto const& e : v) {
        n.push_back(toYaml(e));
    }
    return n;
}

template <typename T>
auto toYaml(T const& t) -> YAML::Node {
    if constexpr (std::is_enum_v<T>) {
        return toYaml(t);
    } else {
        return t.toYaml();
    }
}

template <typename ...Args>
auto toYaml(std::variant<Args...> const& t) -> YAML::Node {
    return std::visit([](auto const& e) {
        return toYaml(e);
    }, t);
}
