from typing import (
    Any,
    Dict,
    Iterable,
    List,
    Match,
    Optional,
    Pattern,
    Sequence,
    Tuple,
    Type,
)

HTML_TAGNAME: str
HTML_ATTRIBUTES: str
ESCAPE_CHAR: Pattern[str]
LINK_TEXT: str
LINK_LABEL: str

class InlineGrammar:
    escape: Pattern[str]
    inline_html: Pattern[str]
    autolink: Pattern[str]
    link: Pattern[str]
    reflink: Pattern[str]
    nolink: Pattern[str]
    url: Pattern[str]
    double_emphasis: Pattern[str]
    emphasis: Pattern[str]
    code: Pattern[str]
    linebreak: Pattern[str]
    strikethrough: Pattern[str]
    footnote: Pattern[str]
    text: Pattern[str]
    def hard_wrap(self) -> None: ...

class InlineLexer:
    grammar_class: Type[InlineGrammar]
    default_rules: List[str]
    inline_html_rules: List[str]
    renderer: Renderer
    links: Dict[str, Dict[str, str]]
    footnotes: Dict[str, int]
    footnote_index: int
    _in_link: bool
    _in_footnote: bool
    _parse_inline_html: bool
    rules: InlineGrammar
    def __init__(
        self, renderer: Renderer, rules: Optional[InlineGrammar] = ..., **kwargs: Any
    ) -> None: ...
    def __call__(self, text: str, rules: Optional[Sequence[str]] = ...) -> str: ...
    def setup(
        self,
        links: Optional[Dict[str, Dict[str, str]]],
        footnotes: Optional[Dict[str, int]],
    ) -> None: ...
    line_match: Match[str]
    line_started: bool
    def output(self, text: str, rules: Optional[Sequence[str]] = ...) -> str: ...
    def output_escape(self, m: Match[str]) -> str: ...
    def output_autolink(self, m: Match[str]) -> str: ...
    def output_url(self, m: Match[str]) -> str: ...
    def output_inline_html(self, m: Match[str]) -> str: ...
    def output_footnote(self, m: Match[str]) -> Optional[str]: ...
    def output_link(self, m: Match[str]) -> str: ...
    def output_reflink(self, m: Match[str]) -> Optional[str]: ...
    def output_nolink(self, m: Match[str]) -> Optional[str]: ...
    def output_double_emphasis(self, m: Match[str]) -> str: ...
    def output_emphasis(self, m: Match[str]) -> str: ...
    def output_code(self, m: Match[str]) -> str: ...
    def output_linebreak(self, m: Match[str]) -> str: ...
    def output_strikethrough(self, m: Match[str]) -> str: ...
    def output_text(self, m: Match[str]) -> str: ...

class InlineParser:
    options: Dict[str, str]
    def __init__(self, **kwargs: Any) -> None: ...
    def placeholder(self) -> str: ...
    def block_code(
        self, code: str, lang: Any = ...
    ) -> str: ...  # It seems that lang should be string, however other types are valid as well
    def block_quote(self, text: str) -> str: ...
    def block_html(self, html: str) -> str: ...
    def header(self, text: str, level: int, raw: Optional[str] = ...) -> str: ...
    def hrule(self) -> str: ...
    def list(
        self, body: Any, ordered: bool = ...
    ) -> str: ...  # body - same reason as for lang above, and for other Any in this class
    def list_item(self, text: Any) -> str: ...
    def paragraph(self, text: str) -> str: ...
    def table(self, header: Any, body: Any) -> str: ...
    def table_row(self, content: Any) -> str: ...
    def table_cell(self, content: Any, **flags: Dict[str, Any]) -> str: ...
    def double_emphasis(self, text: Any) -> str: ...
    def emphasis(self, text: Any) -> str: ...
    def codespan(self, text: str) -> str: ...
    def linebreak(self) -> str: ...
    def strikethrough(self, text: Any) -> str: ...
    def text(self, text: Any) -> str: ...
    def escape(self, text: Any) -> str: ...
    def autolink(self, link: Any, is_email: bool = ...) -> str: ...
    def link(self, link: Any, title: Any, text: Any) -> str: ...
    def image(self, src: Any, title: Any, text: Any) -> str: ...
    def inline_html(self, html: Any) -> str: ...
    def newline(self) -> str: ...
    def footnote_ref(self, key: Any, index: int) -> str: ...
    def footnote_item(self, key: Any, text: str) -> str: ...
    def footnotes(self, text: Any) -> str: ...
